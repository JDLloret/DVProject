---
title: "Home Assignment: Exploratory analysis and visualization"
output: html_document
date: "2025-05-15"
author: "Joan Lloret and Martí Díez"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries

```{r libraries}
library(ggplot2)
library(ggfortify)
library(factoextra)
library(stats)
library(Rtsne)
library(dplyr)
library(tidyr)
library(patchwork)
library(gridExtra)
```

# QUESTION 1: Load, adapt the data and create metadata
# Load the data files

```{r data}
rep1 <- read.csv("./data/rep1.csv")
rep2 <- read.csv("./data/rep2.csv")
rep3 <- read.csv("./data/rep3.csv")
rep4 <- read.csv("./data/rep4.csv")
```

# Check the dimensions of the data, fix rows and transpose the matrix to ensure the data is properly displayed

```{r}
rows <- nrow(rep1)
columns <- ncol(rep1)
cat("The data set rep1 has", rows, "rows and", columns, "columns.\n")

rows <- nrow(rep2)
columns <- ncol(rep2)
cat("The data set rep2 has", rows, "rows and", columns, "columns.\n")

rows <- nrow(rep3)
columns <- ncol(rep3)
cat("The data set rep3 has", rows, "rows and", columns, "columns.\n")

rows <- nrow(rep4)
columns <- ncol(rep4)
cat("The data set rep4 has", rows, "rows and", columns, "columns.\n")


rownames(rep1) <- rep1$X
rep1$X <- NULL

rownames(rep2) <- rep2$X
rep2$X <- NULL

rownames(rep3) <- rep3$X
rep3$X <- NULL

rownames(rep4) <- rep4$X
rep4$X <- NULL

all_equal <- all(rownames(rep1) == rownames(rep2)) &&
             all(rownames(rep1) == rownames(rep3)) &&
             all(rownames(rep1) == rownames(rep4))
cat("Gene name order identical across datasets:", all_equal, "\n")


rep1 <- t(rep1)
rep2 <- t(rep2)
rep3 <- t(rep3)
rep4 <- t(rep4)

```

# Create the metadata and bind the datasets for posterior analysis

```{r}
replicate <- rep(c("1", "2", "3", "4"), each = nrow(rep1))

A_B_vector <- rep(c("A", "B"), each = nrow(rep1) / 2)

metadata <- data.frame(replicate, A_B_vector)

data <- rbind(rep1, rep2, rep3, rep4)
```



# QUESTION 2: PCA representation
There are three types of PCA representations:
Unscaled, Scaled and Normalized. The unscaled representation uses raw data and can lead to an uneven representation since it can emphasize genes with higher overall expression.
The scaled representation scales and centers the data and highlights changes across conditions.
The normalized representation adjusts for the total expression. This means that each sample has a similar total expression level. This representation is used when we compare samples where the total expression might vary a lot. 
```{r}
set.seed(123)

# UNSCALED PCA
pca_unscaled <- prcomp(data, scale = FALSE)
names(pca_unscaled)

# SCALED PCA
pca_scaled <- prcomp(data, scale = TRUE)
names(pca_scaled)

# NORMALIZE THE DATA
sum_data <- rowSums(data)
normalized_data <- sweep(data, 1, sum_data, "/")

# NORMALIZED PCA
pca_normalized <- prcomp(normalized_data, scale = TRUE)
```


# Plot the PCA representations

# Unscaled PCA plot
```{r}
pca1_unscaled <- fviz_pca_ind(pca_unscaled,
                              geom.ind = "point",
                              habillage = metadata$A_B_vector,
                              addEllipses = TRUE,
                              title = "A/B experiment")

pca2_unscaled <- fviz_pca_ind(pca_unscaled,
                              geom.ind = "point",
                              habillage = metadata$replicate,
                              addEllipses = TRUE,
                              title = "Replicates")


pca1_unscaled + pca2_unscaled + plot_annotation("Unscaled plots")
```


# Plot full unscaled PCA with ggplot


```{r}
ggplot(pca_unscaled$x,
       aes(x = PC1,
           y = PC2, 
           color = metadata$replicate,
           shape = metadata$A_B_vector))+
  geom_point()+
  labs(title = "Unscaled PCA")+
  scale_shape_manual(values = c(16, 1))+
  guides(color = guide_legend(title = "Replicates"),
         shape = guide_legend(title = "A/B Experiment"))+
  theme_light()
```


# Scaled PCA plot


```{r}
pca1_scaled <- fviz_pca_ind(pca_scaled,
                              geom.ind = "point",
                              habillage = metadata$A_B_vector,
                              addEllipses = TRUE,
                              title = "A/B experiment")

pca2_scaled <- fviz_pca_ind(pca_scaled,
                              geom.ind = "point",
                              habillage = metadata$replicate,
                              addEllipses = TRUE,
                              title = "Replicates")


pca1_scaled + pca2_scaled + plot_annotation("Scaled plots")
```



# Plot full scaled PCA plot with ggplot


```{r}
ggplot(pca_scaled$x,
       aes(x = PC1,
           y = PC2, 
           color = metadata$replicate,
           shape = metadata$A_B_vector))+
  geom_point()+
  labs(title = "Scaled PCA")+
  scale_shape_manual(values = c(16, 1))+
  guides(color = guide_legend(title = "Replicates"),
         shape = guide_legend(title = "A/B Experiment"))+
  theme_light()
```


# Normalized PCA plot

```{r}
pca1_normalized <- fviz_pca_ind(pca_normalized,
                              geom.ind = "point",
                              habillage = metadata$A_B_vector,
                              addEllipses = TRUE,
                              title = "A/B experiment")

pca2_normalized <- fviz_pca_ind(pca_normalized,
                              geom.ind = "point",
                              habillage = metadata$replicate,
                              addEllipses = TRUE,
                              title = "Replicates")


pca1_normalized + pca2_normalized + plot_annotation("Normalized plots")
```
# Plot full normalized PCA with ggplot
```{r}
ggplot(pca_normalized$x,
       aes(x = PC1,
           y = PC2, 
           color = metadata$replicate,
           shape = metadata$A_B_vector))+
  geom_point()+
  labs(title = "Normalized PCA")+
  scale_shape_manual(values = c(16, 1))+
  guides(color = guide_legend(title = "Replicates"),
         shape = guide_legend(title = "A/B Experiment"))+
  theme_light()
```


# Outliers

```{r}

# Find outliers
point <- data.frame(pca_normalized$x)

absolute_point <- abs(point)

max_value <- max(absolute_point, na.rm = TRUE)

max_pos <- which(absolute_point == max_value, arr.ind = TRUE)

rowname <- rownames(point)[max_pos[1]]
colname <- colnames(point)[max_pos[2]]


# Remove outliers
data <- data[-max_pos[1],]
metadata <- metadata[-max_pos[1],]


# Normalize again
set.seed(123)
sum_data <- rowSums(data)
normalized_data <- sweep(data, 1, sum_data, "/")

pca_normalized <- prcomp(normalized_data, scale = TRUE)
```

# Plot full normalized PCA without outliers with ggplot
```{r}
ggplot(pca_normalized$x,
       aes(x = PC1,
           y = PC2, 
           color = metadata$replicate,
           shape = metadata$A_B_vector))+
  geom_point()+
  labs(title = "Normalized PCA")+
  scale_shape_manual(values = c(16, 1))+
  guides(color = guide_legend(title = "Replicates"),
         shape = guide_legend(title = "A/B Experiment"))+
  theme_light()
```
# tSNE representation
```{r}
maximum_perplexity <- (nrow(normalized_data) - 1) / 3 

# Unscaled tSNE
unscaled_tsne <- Rtsne(data, dims = 2, perplexity = maximum_perplexity/2) 

# If we add verbose = TRUE it will tell us the error value for each 50 iterations until the maximum iterations default value, but it is unnecessary text. The tSNE is performed well for each case.

unscaled_tsne_data <- data.frame(unscaled_tsne$Y, 
                                 replicate = metadata$replicate, A_B_vector = metadata$A_B_vector)

colnames(unscaled_tsne_data) <- c("Dim1", "Dim2", "Replicate", "Type")


# Scaled tSNE
scaled_data <- scale(data)

scaled_tsne <- Rtsne(scaled_data, dims = 2, perplexity = maximum_perplexity/2)

scaled_tsne_data <- data.frame(scaled_tsne$Y, replicate = metadata$replicate, A_B_vector = metadata$A_B_vector)
colnames(scaled_tsne_data) <- c("Dim1", "Dim2", "Replicate", "Type")


#Normalized
sum_data <- rowSums(data)
normalized_data <- sweep(data, 1, sum_data, "/")

normalized_tsne <- Rtsne(normalized_data, dims = 2, 
                         perplexity = maximum_perplexity/2)

normalized_tsne_data <- data.frame(normalized_tsne$Y, 
                                   replicate = metadata$replicate, A_B_vector = metadata$A_B_vector)

colnames(normalized_tsne_data) <- c("Dim1", "Dim2", "Replicate", "Type")
```

# tSNE plots
# Unscaled tSNE plot

```{r}
ggplot(unscaled_tsne_data, aes(x = Dim1, y = Dim2, color = Replicate, shape = Type))+
  geom_point(size = 2)+
  labs(title = "Unscaled tSNE plot")+
    scale_shape_manual(values = c(16, 1)) +
  guides(color = guide_legend(title = "Replicate"),
         shape = guide_legend(title = "Type")) +
  theme_light()
```
# Scaled tSNE plot
```{r}
ggplot(scaled_tsne_data, aes(x = Dim1, y = Dim2, color = Replicate, shape = Type))+
  geom_point(size = 2)+
  labs(title = "Scaled tSNE plot")+
    scale_shape_manual(values = c(16, 1)) +
  guides(color = guide_legend(title = "Replicate"),
         shape = guide_legend(title = "Type")) +
  theme_light()
```

# Normalized tSNE plot

```{r}
ggplot(normalized_tsne_data, aes(x = Dim1, y = Dim2, color = Replicate, shape = Type))+
  geom_point(size = 2)+
  labs(title = "Normalized tSNE plot")+
    scale_shape_manual(values = c(16, 1)) +
  guides(color = guide_legend(title = "Replicate"),
         shape = guide_legend(title = "Type")) +
  theme_light()
```
# tSNE parameters

# Reproducibility

```{r reproducibility}
set.seed(123)

plot_reproducibility <- function(normalized_data, metadata){
  
  set.seed(123)
  maximum_perplexity <- (nrow(normalized_data) - 1) / 3
  data <- Rtsne(normalized_data, perplexity = maximum_perplexity / 2)
  
  tsne_plots <- ggplot(data$Y, aes(x=data$Y[,1], y=data$Y[,2], color=metadata$replicate, shape = metadata$A_B_vector))+
    geom_point()+
    labs(x="tSNE 1", y="tSNE 2", color="Origin", shape = "Experiment Label")
  
  return(tsne_plots)
}


reproducibility_values <- list()

for (i in 1:4){
  
  rep_plot <- plot_reproducibility(normalized_data, metadata)+ggtitle(paste0(i, " tSNE repetition"))
  reproducibility_values[[i]] <- rep_plot
}

grid.arrange(grobs = reproducibility_values, ncol=2, top="tSNE Repetitions")

```

# Perplexity
```{r perplexity}


PerplexityPlotter <- function(normalized_data, metadata, pr){
  
  set.seed(123)
  model <- Rtsne(normalized_data, perplexity = pr)
  tsne_plots <- ggplot(model$Y, aes(model$Y[,1],
                       model$Y[,2],
                       color = metadata$replicate,
                       shape = metadata$A_B_vector))+
    geom_point()+
    labs(x = "tSNE 1", y = "tSNE 2", color = "Replicate", shape = "Type", title=paste0("tSNE plot for perplexity=", round(pr, 2)))
  return(tsne_plots)
}

maximum_perplexity <- (nrow(normalized_data) - 1) / 3 

test_perplexity_values <- c(1, maximum_perplexity/3, (maximum_perplexity/3) * 2, maximum_perplexity)

perplexity_plots <- list()

for (i in seq_along(test_perplexity_values)){
  per_val <- test_perplexity_values[i]
  per_plot <- PerplexityPlotter(normalized_data, metadata, per_val)
  perplexity_plots[[i]] <- per_plot
}

grid.arrange(grobs=perplexity_plots, ncol=2, top="tSNE Perplexity")

```
# Iterations

```{r iterations}

plot_iterations<-function(normalized_data, metadata, num_iterations){
  set.seed(123)
  
  maximum_perplexity <- (nrow(normalized_data)-1)/3
  data <- Rtsne(normalized_data, perplexity = maximum_perplexity / 2, max_iter = num_iterations)

  tsne_plots <- ggplot(data$Y, aes(x=data$Y[,1], y=data$Y[,2], 
                          color=metadata$replicate, shape = metadata$A_B_vector))+
    geom_point()+
    labs(x="tSNE 1", y="tSNE 2", color="Replicate", shape = "Type", 
         title=paste0(num_iterations, " iterations tSNE plot"))
  return(tsne_plots)
}

iterations<-c(2, 100, 2000, 10000)

iterations_plots <- list()

for (i in seq_along(iterations)){
  iter_num <- iterations[i]
  iter_plot <- plot_iterations(normalized_data, metadata, iter_num)
  iterations_plots[[i]] <- iter_plot
}

grid.arrange(grobs = iterations_plots, ncol = 2, top="tSNE Iterations")
```

# Final interpretation

# We'll use the normalized data with outliers removed since it is the one that represents our data most accurately

# Final PCA
```{r final_pca}
final_pca1 <- ggplot(pca_normalized$x,
                     aes(x = PC1, y = PC2, color = metadata$replicate, shape = metadata$A_B_vector))+
  geom_point()+
  scale_shape_manual(values = c(16,1))+
  guides(color = guide_legend(title = "Replicate"),
      shape = guide_legend(title = "Type"))+
  theme_light()



final_pca2 <- fviz_pca_ind(pca_normalized,              geom.ind = "point", 
             habillage = metadata$A_B_vector,
             addEllipses = TRUE) +
  labs(x = "PC1", y = "PC2")+
  theme_light()

final_pca1 + final_pca2 + plot_annotation(title = "Final PCA representation with accurate data")

```
We observe that our data has been grouped into two clusters, which are classified by the type of experiment (not the replicate where they come from) and this means that the variance that is seen between PC1 and PC2 has to be explained by biological factors. Since the groups are clearly separated, we can confirm that the batch effect has been eliminated. 

# Final tSNE representation


```{r}
set.seed(123)

maximum_perplexity <- (nrow(normalized_data) - 1) / 3

ggplot(normalized_tsne_data, aes(x = Dim1, y = Dim2, color = metadata$replicate, shape = metadata$A_B_vector)) +
  geom_point(size = 2) +
  labs(title = "Final tSNE representation with accurate data", 
       x = "Dim1", y = "Dim2", color = "Replicate", shape = "Type") +
  theme_minimal()
```
The t-SNE plot shows how samples group based on how similar they are, and it helps support what we saw with the PCA. In our plot, the samples are grouped more by their experimental type (A/B) than what replicate they came from. This suggests that the differences in the data are due to real biological effects, not technical issues like batch effects. This supports the PCA representation since both PCA and tSNE are clustered the same way.



# Final interpretation

PCA and tSNE both help understand the main differences in our data. PCA showed clear clusters in the first two components, and tSNE showed a similar pattern in its two main dimensions. Looking back at the results, the fact that both methods show the same clear grouping gives us more confidence in what we're seeing. Since the clusters match the experiment type rather than the replicate where it comes from, we can say that the variation is likely caused by biology, not technical errors.
